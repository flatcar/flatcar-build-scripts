#!/bin/bash
set -euo pipefail

FETCH="${FETCH-1}"
SCRIPTFOLDER="$(dirname "$(readlink -f "$0")")"

if [ $# -lt 1 ] || [ "$1" = "-h" ] || [ "$1" = "--help" ]; then
  echo "Usage: $0 OLD [NEW]"
  echo "Shows the changes between the git references by assembling the changelog/ folder entries"
  echo "By default the script assumes that it is being run in the folder that contains the scripts repository folder. Set SCRIPTS_REPO to contain the path to the repo if the default assumption is wrong."
  echo "The NEW reference can be omitted and will then default to HEAD."
  exit 1
fi

: "${SCRIPTS_REPO:=scripts}"

OLD="$1"
NEW="${2-HEAD}"
OLD_FMT=""

# The release tags are usually in format of (alpha|beta|stable|lts-XXXX.Y.Z) but
# what we need in the formatted output is (Alpha|Beta|Stable|LTS XXXX.Y.Z).
# The given code transform the given name into the desired output.
if [[ $OLD == *"lts"* ]]; then
  OLD_FMT=$(echo "${OLD}" | tr "-" " " | tr '[:lower:]' '[:upper:]')
else
  OLD_FMT=$(echo "${OLD}" | tr "-" " " | sed 's/./\U&/')
fi

echo "_Changes since **${OLD_FMT}**_"

if [[ ${FETCH} = 1 ]]; then
  for repo in scripts; do
    var_name=${repo//-/_}
    var_name="${var_name^^}_REPO"
    if [[ -d ${!var_name} ]]; then
      git -C "${!var_name}" fetch -t -f 2> /dev/null > /dev/null || { echo "Error: git fetch -t -f failed for ${repo}" ; exit 1 ; }
    fi
  done
fi

for section in security bugfixes changes updates; do
  echo
  case "${section}" in
    security)
      echo "#### Security fixes:"
      ;;
    bugfixes)
      echo "#### Bug fixes:"
      ;;
    changes)
      echo "#### Changes:"
      ;;
    updates)
      echo "#### Updates:"
      ;;
    *)
      echo "wrong cases" > /dev/stderr
      exit 1
  esac
  echo
  for repo in scripts; do
    var_name=${repo//-/_}
    var_name="${var_name^^}_REPO"
    OLDREF="${OLD}"
    NEWREF="${NEW}"
    REPOPATH="${!var_name}"
    if [ "${section}" = "security" ] && [ "${repo}" = "scripts" ]; then
      FROM_KERNEL=$({ git -C "${REPOPATH}" show "${OLDREF}":repos/flatcar-overlay/sys-kernel/coreos-kernel/ 2>/dev/null || git -C "${REPOPATH}" show "${OLDREF}":sdk_container/src/third_party/coreos-overlay/sys-kernel/coreos-kernel/; } | grep -m 1 'coreos-kernel-.*\.ebuild' | cut -d - -f 3 | cut -d . -f 1-3)
      TO_KERNEL=$({   git -C "${REPOPATH}" show "${NEWREF}":repos/flatcar-overlay/sys-kernel/coreos-kernel/ 2>/dev/null || git -C "${REPOPATH}" show "${NEWREF}":sdk_container/src/third_party/coreos-overlay/sys-kernel/coreos-kernel/; } | grep -m 1 'coreos-kernel-.*\.ebuild' | cut -d - -f 3 | cut -d . -f 1-3)
      if [ "${FROM_KERNEL}" != "${TO_KERNEL}" ]; then
        KERNEL_ENTRIES=$("${SCRIPTFOLDER}"/show-fixed-kernel-cves.py -f "${FROM_KERNEL}" -t "${TO_KERNEL}")
        if [ "${KERNEL_ENTRIES}" != "" ]; then
          echo "- Linux (${KERNEL_ENTRIES})"
        fi
      fi
    fi

    git -C "${REPOPATH}" difftool --no-prompt --extcmd='sh -c "cat \"$REMOTE\"" --' "${OLDREF}..${NEWREF}" -- "changelog/${section}/" | sort || { echo "Error: git difftool failed" ; exit 1 ; }
    # The -x 'sh -c "cat \"$REMOTE\"" --' command assumes that new changes have their own changelog files,
    # and thus ignores the LOCAL file (which is the empty /dev/null) and prints out the REMOTE completly.
    # If an existing file got changed, we assume that this is just a correction for the old change but
    # shouldn't be included in the release notes again.
  done
done
